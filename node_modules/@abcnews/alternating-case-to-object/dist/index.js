"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  default: () => src_default
});
module.exports = __toCommonJS(src_exports);
var makeArray = (val) => typeof val === "string" ? [val] : val;
function src_default(string, { propMap = {}, arrayProps = [], noTypeGuessing = [] } = {}) {
  const config = string.match(/[A-Z]+([0-9a-z]|$)+/g) || [];
  arrayProps = makeArray(arrayProps);
  noTypeGuessing = makeArray(noTypeGuessing);
  const result = config.map((str) => {
    const [, keyStr, valueStr] = str.match(/^([A-Z]+)([0-9a-z]*$)/) || [];
    if (typeof keyStr !== "string" || typeof valueStr !== "string") {
      throw new Error("Error reading key/value pair");
    }
    const key = propMap[keyStr.toLowerCase()] || keyStr.toLowerCase();
    const value = noTypeGuessing.includes(key) ? valueStr : parseFloat(valueStr).toString() === valueStr ? parseFloat(valueStr) : valueStr === "true" || valueStr === "yes" ? true : valueStr === "false" || valueStr === "no" ? false : valueStr === "" ? null : valueStr;
    return { key, value };
  }).reduce((obj, { key, value }, _, arr) => {
    if (typeof obj[key] !== "undefined")
      return obj;
    const allKeyValues = arr.filter(({ key: k }) => k === key).map((d) => d.value);
    const makeArray2 = arrayProps.includes(key) || allKeyValues.length > 1;
    if (makeArray2) {
      const err = new Error(
        "Inconsistent types in array property '" + key + "'"
      );
      if (typeof value === "string") {
        const vals = allKeyValues.filter(
          (d) => typeof d === "string"
        );
        if (vals.length !== allKeyValues.length)
          throw err;
        obj[key] = vals;
      }
      if (typeof value === "number") {
        const vals = allKeyValues.filter(
          (d) => typeof d === "number"
        );
        if (vals.length !== allKeyValues.length)
          throw err;
        obj[key] = vals;
      }
      if (typeof value === "boolean") {
        const vals = allKeyValues.filter(
          (d) => typeof d === "boolean"
        );
        if (vals.length !== allKeyValues.length)
          throw err;
        obj[key] = vals;
      }
    } else {
      obj[key] = value;
    }
    return obj;
  }, {});
  arrayProps.forEach((key) => {
    if (typeof result[key] === "undefined") {
      result[key] = [];
    }
  });
  return result;
}
//# sourceMappingURL=index.js.map